---
title: 你不知道的JS系列（四）
comments: true
toc: true
tags: js
date: 2018-05-21 22:55:39
categories: js
---
# 一、this判定
现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 this 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。

1.函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。
``` bash
var bar = new foo()
```
2.函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。
``` bash
var bar = foo.call( obj2 )
```
3.函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。
``` bash
var bar = obj1.foo()
```
4.否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。
``` bash
var bar = foo()
```
以上，就是理解对于普通的函数调用来说的 this 绑定规则 所需的全部。是的……几乎是全部。

ps:
如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。

# 二、闭包的定义
闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。
通俗点：无论何时何地 只要你将函数作为头等的值看待并将它们传来传去的话，你就可能看到这些函数行使闭包。
计时器、事件处理器、Ajax请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个 回调函数，你就在它周围悬挂了一些闭包！
另外模块也是闭包的表现形式：ES6，AMD，CMD模式都一样。